[{"body":"","link":"https://jukhang.github.io.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://jukhang.github.io.github.io/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://jukhang.github.io.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://jukhang.github.io.github.io/tags/tcp/","section":"tags","tags":null,"title":"tcp"},{"body":"","link":"https://jukhang.github.io.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","section":"categories","tags":null,"title":"计算机网络"},{"body":"传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。\nOSI模型 tcp报文格式 源端口、目的端口：和IP协议中的源IP、目的IP一起确定每一个确定的连接。TCP的包是没有IP地址的，那是IP层上的事。 Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。 Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。 首部长度 (数据偏移,Header Length)：由于选项部分长度可变，所以需要首部长度字段明确表示首部的长度。 Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控，指定流控窗口的大小。 控制标记位: URG (Urgent Bit)：紧急指针是否有效，1表示有效 ACK (Acknowledgment Bit)：1表示确认号字段有效 PSH (Push Bit)：接收方是否尽快将报文段交给应用层，1表示有效，接收方应该尽快将报文段交给应用层而不用等待缓冲区装满。 RST (Reset Bit)：重建连接，为1表示出现严重差错。可能需要重新建立TCP连接。可以用于拒绝非法的报文段和拒绝连接请求。 SYN (Synchronize Bit)：用于发起一个连接，为1表示这是连接请求或是连接接受请求，用于建立连接和使顺序号同步。 FIN (Finish Bit)：用于关闭连接，为1表示发送方没有数据要传输了，要求释放连接。 校验和 (Checksum)：用于校验数据的完整性。 紧急指针 (Urgent Pointer)：当URG为1时生效，用于TCP发送端向接受端发送紧急数据。 tcp状态机、三次握手和四次挥手 对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。 对于4次挥手，因为TCP是全双工的，所以，发送方和接收方都需要FIN和ACK。 主动断开链接的一方，会出现 TIME_WAIT 状态。 参考 传输控制协议 TCP/IP Guide TCP/IP Reference TCP 的那些事儿（上） TCP: About FIN_WAIT_2, TIME_WAIT and CLOSE_WAIT ","link":"https://jukhang.github.io.github.io/post/network_tcp/","section":"post","tags":["tcp"],"title":"计算机网络协议之TCP"},{"body":"","link":"https://jukhang.github.io.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/","section":"tags","tags":null,"title":"并查集"},{"body":"","link":"https://jukhang.github.io.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"tags","tags":null,"title":"数据结构"},{"body":"并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。用于解决图的连通性问题，即给定一个无向图，要求判断某两个元素之间是否存在相连的路径（连通）。\n并查集支持两种操作： 合并（Union）：合并两个元素所属集合（合并对应的树） 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合 1class UF: 2 \u0026#34;\u0026#34;\u0026#34; 3 self.id 存当前id的祖宗节点 4 self.size 当节点是祖宗节点时有效。每个节点都是其自身的祖宗（默认为1） 5 \u0026#34;\u0026#34;\u0026#34; 6 def __init__(self, n): 7 self.id = list(range(n)) # 初始化每个节点都是其自身的祖宗 8 self.size = [1] * n 9 10 def find(self, p): 11 if (self.id[p] == p): 12 return p 13 self.id[p] = find(self.id[p]) 14 return self.id[p] 15 16 def union(self, p, q): 17 p_root = self.find(p) 18 q_root = self.find(q) 19 20 if (p_root != q_root) { 21 if(self.size[p_root] \u0026lt; self.size[q_root]) { # qRoot是祖宗节点 22 self.id[p_root] = self.id[q_root]; 23 self.size[q_root] += self.size[p_root]; # 祖宗节点的 size += 24 }else { 25 self.id[q_root] = self.id[p_root]; # pRoot是祖宗节点 26 self.size[p_root] += self.size[q_root]; # 祖宗节点的 size += 27 } 28 } ","link":"https://jukhang.github.io.github.io/post/union_find_set/","section":"post","tags":["并查集","数据结构"],"title":"数据结构之并查集"},{"body":"","link":"https://jukhang.github.io.github.io/categories/%E7%AE%97%E6%B3%95/","section":"categories","tags":null,"title":"算法"},{"body":"","link":"https://jukhang.github.io.github.io/tags/c++/","section":"tags","tags":null,"title":"C++"},{"body":"排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。\n排序算法稳定性：如果两个相等的数字，排序完成后，相对顺序不变，是稳定，否则是不稳定 排序算法优化思路：减少比较次数，减少交换次数。 1#pragma once 2 3#include \u0026lt;vector\u0026gt; 4#include \u0026lt;utility\u0026gt; 5 6class MySort { 7public: 8 void bubble(std::vector\u0026lt;int\u0026gt;\u0026amp;); 9 void insertion(std::vector\u0026lt;int\u0026gt;\u0026amp;); 10 void selection(std::vector\u0026lt;int\u0026gt;\u0026amp;); 11 void quick(std::vector\u0026lt;int\u0026gt;\u0026amp;, size_t, size_t); 12 void heap(std::vector\u0026lt;int\u0026gt;\u0026amp;); 13 14private: 15 void max_heapify(std::vector\u0026lt;int\u0026gt;\u0026amp;, size_t); 16}; 1. 冒泡排序 冒泡排序两层循环，内层循环依次比较相邻值的大小，将较大值依次向后交换，类似水中上浮的泡泡，逐渐变大，每次内层循环结束，最大值均出现在正确的位置。\n1void MySort::bubble(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { 2 for (size_t i = 0; i \u0026lt; nums.size(); i++) 3 { 4 for (size_t j = 0; j \u0026lt; nums.size()-i-1; j++) 5 { 6 if (nums[j] \u0026gt; nums[j+1]) 7 { 8 std::swap(nums[j], nums[j+1]); 9 } 10 } 11 } 12} 2. 选择排序 1void MySort::selection(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { 2 for (size_t i = 0; i \u0026lt; nums.size(); i++) 3 { 4 size_t min_index = i; 5 for (size_t j = i+1; j \u0026lt; nums.size(); j++) 6 { 7 if (nums[j] \u0026lt; nums[min_index]) { 8 min_index = j; 9 } 10 } 11 12 std::swap(nums[i], nums[min_index]); 13 } 14} 3. 插入排序 1void MySort::insertion(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { 2 for (size_t i = 1; i \u0026lt; nums.size(); i++) 3 { 4 size_t j = i; 5 while (j \u0026gt; 0) { 6 if (nums[j] \u0026gt;= nums[j-1]) { 7 break; 8 } 9 else // (nums[j] \u0026lt; nums[j-1]) 10 { 11 std::swap(nums[j-1], nums[j]); 12 } 13 --j; 14 } 15 } 16} 4. 快速排序 1void MySort::quick(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, size_t low, size_t high) { 2 if (low \u0026gt;= high) { 3 return; 4 } 5 6 size_t left = low; 7 size_t right = high; 8 int pivot = nums[left]; 9 10 // 选择第一个值作为基准值 11 // 从后往前，找第一个小于基准值的值，将其值调换到前面。 12 // 从前往后，找第一个大于基准值的值，将其值调换到后面 13 while (left \u0026lt; right) { 14 while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) { 15 --right; 16 } 17 nums[left] = nums[right]; 18 while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt;= pivot) { 19 ++left; 20 } 21 nums[right] = nums[left]; 22 } 23 nums[left] = pivot; 24 25 quick(nums, low, left - 1); 26 quick(nums, left + 1, high); 27} 5. 堆排序 1void MySort::heap(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { 2 for (size_t i = nums.size(); i \u0026gt; 0; --i) 3 { 4 max_heapify(nums, i); 5 6 // 堆顶元素和Kn交换 7 std::swap(nums[0], nums[i-1]); 8 } 9} 10 11void MySort::max_heapify(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, size_t limit) { 12 size_t length = nums.size(); 13 if (length \u0026lt; 0 || length \u0026lt; limit) { 14 return; 15 } 16 17 int parent_idx = static_cast\u0026lt;int\u0026gt;(limit) \u0026gt;\u0026gt; 1; 18 for (; parent_idx \u0026gt;= 0; parent_idx--) 19 { 20 if (parent_idx * 2 \u0026gt;= limit) { 21 continue; 22 } 23 24 int left = parent_idx * 2; 25 int right = (left + 1) \u0026gt;= limit ? left : (left + 1); 26 27 int max_child_idx = nums[left] \u0026gt; nums[right] ? left : right; 28 if (nums[max_child_idx] \u0026gt; nums[parent_idx]) { 29 std::swap(nums[parent_idx], nums[max_child_idx]); 30 } 31 } 32} ","link":"https://jukhang.github.io.github.io/post/sort-algorithm-cpp/","section":"post","tags":["排序算法","C++"],"title":"几种排序算法的实现"},{"body":"","link":"https://jukhang.github.io.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"tags","tags":null,"title":"排序算法"},{"body":"","link":"https://jukhang.github.io.github.io/tags/katex/","section":"tags","tags":null,"title":"KaTex"},{"body":"","link":"https://jukhang.github.io.github.io/categories/%E6%95%B0%E5%AD%A6/","section":"categories","tags":null,"title":"数学"},{"body":"在网页中展示数学公式，使 Hugo 支持 LaTex 形式。已经生成好的静态页面中，使用 JavaScript 来渲染 LaTeX 形式的数学公式，本博客采用 KaTex 来渲染前端数学公式。\n数学公式有行内（inline）公式和区块（block）公式。 前者需要与同行的其它文字混排，而后者需要独占一行，居中显示。以下展示了两个行内公式和一个区块公式的测试代码。\n行内公式: \\(ax^2 + bx + c = 0 \\)\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} \\tag{1}$$\n矩阵 没有括号的矩阵 $$ \\begin{matrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{matrix} \\tag{2} $$ 括号 {} 的矩阵 $$ \\begin{Bmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{Bmatrix} \\tag{3} $$ 括号 [] 的矩阵 $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{bmatrix} \\tag{4} $$ 对齐 使用 {aligned} 和 \u0026amp; 标记要对齐的位置，否则每行的公式自身都是居中的。\n$$ \\bigg\\lbrace\\begin{aligned} \u0026 x = 16\\sin^3t \\\\ \u0026 y = 13\\cos{t} - 5\\cos{2t} - 2\\cos{3t} - \\cos{4t} \\end{aligned} \\tag{5} $$ 上下标 $$ \\sum_{i=1}^n a_i \\tag{6} $$\n和、积、极限、积分 $$ \\sum_{i=1}^n a_i \\tag{7} $$\n$$ \\prod_{i=1}^n a_i \\tag{8} $$\n$$ \\lim_{x\\to\\infty} {1 \\over \\sqrt{x}} \\tag{9} $$\n$$ \\int_{-\\infty}^\\infty \\hat f\\xi,e^{2 \\pi i \\xi x} ,d\\xi \\tag{10} $$\n$$ \\to \\tag{11} $$\n省略号、空格 $$ \\dots \\quad \\cdots \\quad \\vdots \\quad \\ddots \\tag{12} $$\n上下水平划线 $$ \\overline{m+n} \\quad \\underline{m+n} \\tag{13} $$\n向量 使用 \\vec 语法。另两个命令 \\overrightarrow 和 \\overleftarrow 定义向量方向:\n$$ \\vec{a} \\quad \\overrightarrow{AB} \\quad \\overleftarrow{AB} \\tag{14} $$\n分数 分数（fraction）使用 \\frac{...}{...} 排版。\n$$ \\frac {x^2} {k +1} \\tag{15} $$\n","link":"https://jukhang.github.io.github.io/post/katex/","section":"post","tags":["KaTex"],"title":"数学公式常用写法"},{"body":"","link":"https://jukhang.github.io.github.io/","section":"","tags":null,"title":""},{"body":" 为学日益，为道日损。损之又损，以至于无为。无为而无不为。\n","link":"https://jukhang.github.io.github.io/about/","section":"","tags":null,"title":"关于我"},{"body":"","link":"https://jukhang.github.io.github.io/archives/","section":"","tags":null,"title":"文章归档"},{"body":"","link":"https://jukhang.github.io.github.io/series/","section":"series","tags":null,"title":"Series"}]